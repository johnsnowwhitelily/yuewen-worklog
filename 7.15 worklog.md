# 多态

多态是靠虚函数（virtual）实现的。子类继承父类并改写虚函数。

父类指针指向子类，指针调用子类对象；

父类引用指向子类，引用调用子类对象；

子类对象赋值给父类对象，只赋值父类的部分；

# 静态变量（static）

静态变量的作用是限制变量的使用范围；

静态变量的默认初始值为0；

- 类中的静态变量；
- 函数中的静态变量；
- 类中的函数中的静态变量；

# 函数的声明和定义

将函数定义在main函数的后面，在使用前，需要在main函数前进行声明，否则会报错。

将函数定义在main函数的前面，则不需要声明。

- 声明：告诉编译器我要使用这个函数，你现在没有找到它的定义不要紧，请不要报错，稍后我会把定义补上。
- 定义：定义函数的功能

# 全局变量（global）

在执行main函数之前，会先进行全局变量的初始化。

在main函数结束之后，才会进行全局变量的销毁，也就是说全局变量的生命周期是整个程序。

# main的两个参数的意义

int main (int argc,char *argv[]) 

- argc：参数的个数
- argv：argv[0]为自身运行目录路径和程序名，argv[1]指向第一个参数、argv[2]指向第二个参数…… 

# 主线程不能轻易die掉

在众多子线程结束之后，main函数才能结束，所以进入main函数之后会有一个死循环while（flag）{...}

# .obj文件

project中每个cpp经编译成为obj（object）文件，所有obj文件和资源文件经链接(link)成为可执行文件，obj文件可称为目标文件或中间文件。

# header文件

编译器首先编译头文件，然后将这个编译结果保存起来，之后如果有其他源文件include了这个头文件的时候，则自动从这个编译结果提取需要的信息进行编译。

头文件只能包含interface（函数声明、宏定义、类定义（只包含数据成员定义和函数成员声明，不能包含函数成员定义！）），绝对不能包含一丁点的implementation（内部数据结构，实现类、辅助函数等等），否则会导致构建程序的时候的严重的编译链接错误！

# 编译器

> C文件内容如下： 
>
> ```
> #include <stdio.h> 
> #include "mytest.h"int main(int argc,char **argv) 
> { 
> test = 25; 
> printf("test.................%d/n",test); 
> }
> ```
>
> 头文件内容如下： 
>
> ```
> int test;
> ```
>
> 

- 预处理阶段
  编译器以C文件作为一 个单元，首先读这个C文件，发现第一句与第二句是包含一个头文件，就会在所有搜索路径中寻找这两个文件，找到之后，就会将相应头文件中再去处理宏，变量， 函数声明，嵌套的头文件包含等，检测依赖关系，进行宏替换，看是否有重复定义与声明的情况发生，最后将那些文件中所有的东东全部扫描进这个当前的C文件 中，形成一个中间“C文件”
- 词法与语法分析阶段
- 编译阶段
  在上一步中相当于将那个头文件中的test变量扫描进了一个中间C文件，那么test变量就变成了这个文件中的一个全局变量，此时就将所有这个中间C文件的所有变量，函数分配空间，将各个函数编译成二进制码，按照特定目标文件格式生成目标文件，在这种格式的目标文件中进行各个全局变量，函数的符号描述，将这些二进制码按照一定的标准组织成一个目标文件（.obj）
- 连接阶段
  将上一步成生的各个目标文件，根据一些参数，连接生成最终的可执行文件。

# 为何一定要分成头文件与C文件

- 如果在头文件中实现一个函数体，那么如果在多个C文件中引用它，而且又同时编译多个C文件，将其生成的目标文件连接成一个可执行文件，在每个引用此头文件的C文件所生成的目标文件中，都有一份这个函数的代码，如果这段函数又没有定义成局部函数，那么在连接时，就会发现多个相同的函数，就会报错 
- 如果在头文件中定义全局变量，并且将此全局变量赋初值，那么在多个引用此头文件的C文件中同样存在相同变量名的拷贝，关键是此变量被赋了初值，所以编译器就会将此变量放入DATA段，最终在连接阶段，会在DATA段中存在多个相同的变量，它无法将这些变量统一成一个变量，也就是仅为此变量分配一个空间，而不是多份空间，假定这个变量在头文件没有赋初值，编译器就会将之放入 BSS段，连接器会对BSS段的多个同名变量仅分配一个存储空间 
- 如果在C文件中声明宏，结构体，函数等，那么我要在另一个C文件中引用相应的宏，结构体，就必须再做一次重复的工作，如果我改了一个C文件中的一个声明，那么又忘了改其它C文件中的声明，这不就出了大问题了，程序的逻辑就变成 了你不可想象的了，如果把这些公共的东东放在一个头文件中，想用它的C文件就只需要引用一个就OK了！！！这样岂不方便，要改某个声明的时候，只需要动一 下头文件就行了 
- 便于封装

# 一个编译完的程序的结构

- text
  放程序代码的,编译时确定,只读
- data
  存放在编译阶段(而非运行时)就能确定的数据,可读可写
  就是通常所说的静态存储区,赋了初值的全局变量和静态变量存放在这个区域,常量也存放在这个区域
- bss
  定义而没有赋初值的全局变量和静态变量放在这个区域

# 局部函数

```
int main()

{

	auto a = [](){std::cout << "Lambda is flexible!";};
	
	a();    //MinGW或VC10.0通过编译，显示结果：Lambda is flexible!   
	
	return 0;

}
```

函数中的函数

# 含有多个cpp

一个.cpp对应一个.obj,然后将所有的obj链接起来(通过一个叫链接器的程序),组成一个.exe,也就是程序了.

 如果一个.cpp要用到另一个.cpp定义的函数（默认extern）怎么办? 只需在这个.cpp#include头文件然后直接调用就可以了.其余工作由链接器帮你完成,你可以随便调用该函数.

链接器将所有的obj连接起来,但是如果碰巧有相同的函数或外部变量怎么办?他如何识别?

**链接属性的关键字**

- 外部链接extern
  除了这个单元,外部的单元也是能够访问这个函数，整个程序公用

- 内部链接static
  只属于自己单元，只在一个编译单元obj中使用

  

# 深拷贝和浅拷贝

**【浅拷贝】**是增加了一个指针，指向原来已经存在的内存。

​				   在多个对象指向一块空间的时候，释放一个空间会导致其他对象所使用的空间也被释放了，再次释放便会出现错误

**【深拷贝】**是增加了一个指针，并新开辟了一块空间

# c++STL容器的实现原理

- vector：也叫向量，尾部可变长数组。内部通过数组实现。空间不够时会重新分配内存，然后将原来的元素拷贝到新分配的数组中。

- queue：数组、单向队列。先入先出。能将任意类型的序列容器转换为队列，由deque支持。

- deque：数组、双向队列。分配中央控制器map（不是map容器），map记录着一系列固定长度的数组地址，真正的数据放在数组。首尾部可变长数组。空间不够时会分配新数组然后将原数组元素拷贝到新数组。效率低于vector，尽量使用vector。

- stack：使用deque作为支持，能将任意类型的序列容器转换为栈。

- list：双向链表。

- slist：单向链表。

- priotity_queue：有权值的queue，实现原理是堆，使用vector作为底层存储，实现原理也是数组。
  

# 堆和栈

- 栈
  栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。

  ```
  int main()
  {
  	int b;				//栈
  	char s[] = "abc"; 	//栈
  	char *p2;			//栈
  }
  ```

  其中函数中定义的局部变量按照先后定义的顺序依次压入栈中，也就是说相邻变量的地址之间不会存在其它变量。栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量，比如上面代码中变量 s 的地址小于变量 b 的地址，p2 地址小于 s 的地址。栈中存储的数据的生命周期随着函数的执行完成而结束。

- 堆

  堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表。

  ```
  int main()
  {
  	// C 中用 malloc() 函数申请
  	char* p1 = (char *)malloc(10);
  	cout<<(int*)p1<<endl;		//输出：00000000003BA0C0
  	
  	// 用 free() 函数释放
  	free(p1);
     
  	// C++ 中用 new 运算符申请
  	char* p2 = new char[10];
  	cout << (int*)p2 << endl;		//输出：00000000003BA0C0
  	
  	// 用 delete 运算符释放
  	delete[] p2;
  }
  ```

  其中 p1 所指的 10 字节的内存空间与 p2 所指的 10 字节内存空间都是存在于堆。堆的内存地址生长方向与栈相反，由低到高，但需要注意的是，后申请的内存空间并不一定在先申请的内存空间的后面，即 p2 指向的地址并不一定大于 p1 所指向的内存地址，原因是先申请的内存空间一旦被释放，后申请的内存空间则会利用先前被释放的内存，从而导致先后分配的内存空间在地址上不存在先后关系。堆中存储的数据若未释放，则其生命周期等同于程序的生命周期。

  操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确地释放本内存空间。由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动地将多余的那部分重新放入空闲链表。

# 多线程

##### 并发性问题

在多用户环境中，在同一时间可能会有多个用户更新相同的记录，这会产生冲突。

##### 互斥锁

是一种信号量，常用来防止两个进程或线程在同一时刻访问相同的共享资源。

- 原子性
  把一个互斥量锁定为一个原子操作，这意味着操作系统（或pthread函数库）保证了如果一个线程锁定了一个互斥量，没有其他线程在**同一时间**可以成功锁定这个互斥量。

- 唯一性
  如果一个线程锁定了一个互斥量，**在它解除锁定之前**，没有其他线程可以锁定这个互斥量。

- 非繁忙等待

  如果一个线程已经锁定了一个互斥量，第二个线程又试图去锁定这个互斥量，则第二个线程将被挂起（不占用任何cpu资源），直到第一个线程解除对这个互斥量的锁定为止，第二个线程则被唤醒并继续执行，同时锁定这个互斥量。

  