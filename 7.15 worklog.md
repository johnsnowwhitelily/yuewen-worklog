# 多态

多态是靠虚函数（virtual）实现的。子类继承父类并改写虚函数。

父类指针指向子类，指针调用子类对象；

父类引用指向子类，引用调用子类对象；

子类对象赋值给父类对象，只赋值父类的部分；

# 静态变量（static）

静态变量的作用是限制变量的使用范围；

静态变量的默认初始值为0；

- 类中的静态变量；
- 函数中的静态变量；
- 类中的函数中的静态变量；

# 函数的声明和定义

将函数定义在main函数的后面，在使用前，需要在main函数前进行声明，否则会报错。

将函数定义在main函数的前面，则不需要声明。

- 声明：告诉编译器我要使用这个函数，你现在没有找到它的定义不要紧，请不要报错，稍后我会把定义补上。
- 定义：定义函数的功能

# 全局变量（global）

在执行main函数之前，会先进行全局变量的初始化。

在main函数结束之后，才会进行全局变量的销毁，也就是说全局变量的生命周期是整个程序。

# main的两个参数的意义

int main (int argc,char *argv[]) 

- argc：参数的个数
- argv：argv[0]为自身运行目录路径和程序名，argv[1]指向第一个参数、argv[2]指向第二个参数…… 

# 主线程不能轻易die掉

在众多子线程结束之后，main函数才能结束，所以进入main函数之后会有一个死循环while（flag）{...}

# .obj文件

project中每个cpp经编译成为obj（object）文件，所有obj文件和资源文件经链接(link)成为可执行文件，obj文件可称为目标文件或中间文件。

# header文件

编译器首先编译头文件，然后将这个编译结果保存起来，之后如果有其他源文件include了这个头文件的时候，则自动从这个编译结果提取需要的信息进行编译。

头文件只能包含interface（函数声明、宏定义、类定义（只包含数据成员定义和函数成员声明，不能包含函数成员定义！）），绝对不能包含一丁点的implementation（内部数据结构，实现类、辅助函数等等），否则会导致构建程序的时候的严重的编译链接错误！

# 编译器

> C文件内容如下： 
>
> ```
> #include <stdio.h> 
> #include "mytest.h"int main(int argc,char **argv) 
> { 
> test = 25; 
> printf("test.................%d/n",test); 
> }
> ```
>
> 头文件内容如下： 
>
> ```
> int test;
> ```
>
> 

- 预处理阶段
  编译器以C文件作为一 个单元，首先读这个C文件，发现第一句与第二句是包含一个头文件，就会在所有搜索路径中寻找这两个文件，找到之后，就会将相应头文件中再去处理宏，变量， 函数声明，嵌套的头文件包含等，检测依赖关系，进行宏替换，看是否有重复定义与声明的情况发生，最后将那些文件中所有的东东全部扫描进这个当前的C文件 中，形成一个中间“C文件”
- 词法与语法分析阶段
- 编译阶段
  在上一步中相当于将那个头文件中的test变量扫描进了一个中间C文件，那么test变量就变成了这个文件中的一个全局变量，此时就将所有这个中间C文件的所有变量，函数分配空间，将各个函数编译成二进制码，按照特定目标文件格式生成目标文件，在这种格式的目标文件中进行各个全局变量，函数的符号描述，将这些二进制码按照一定的标准组织成一个目标文件（.obj）
- 连接阶段
  将上一步成生的各个目标文件，根据一些参数，连接生成最终的可执行文件。

# 为何一定要分成头文件与C文件

- 如果在头文件中实现一个函数体，那么如果在多个C文件中引用它，而且又同时编译多个C文件，将其生成的目标文件连接成一个可执行文件，在每个引用此头文件的C文件所生成的目标文件中，都有一份这个函数的代码，如果这段函数又没有定义成局部函数，那么在连接时，就会发现多个相同的函数，就会报错 
- 如果在头文件中定义全局变量，并且将此全局变量赋初值，那么在多个引用此头文件的C文件中同样存在相同变量名的拷贝，关键是此变量被赋了初值，所以编译器就会将此变量放入DATA段，最终在连接阶段，会在DATA段中存在多个相同的变量，它无法将这些变量统一成一个变量，也就是仅为此变量分配一个空间，而不是多份空间，假定这个变量在头文件没有赋初值，编译器就会将之放入 BSS段，连接器会对BSS段的多个同名变量仅分配一个存储空间 
- 如果在C文件中声明宏，结构体，函数等，那么我要在另一个C文件中引用相应的宏，结构体，就必须再做一次重复的工作，如果我改了一个C文件中的一个声明，那么又忘了改其它C文件中的声明，这不就出了大问题了，程序的逻辑就变成 了你不可想象的了，如果把这些公共的东东放在一个头文件中，想用它的C文件就只需要引用一个就OK了！！！这样岂不方便，要改某个声明的时候，只需要动一 下头文件就行了 
- 便于封装

# 一个编译完的程序的结构

- text
  放程序代码的,编译时确定,只读
- data
  存放在编译阶段(而非运行时)就能确定的数据,可读可写
  就是通常所说的静态存储区,赋了初值的全局变量和静态变量存放在这个区域,常量也存放在这个区域
- bss
  定义而没有赋初值的全局变量和静态变量放在这个区域

# 局部函数

```
int main()

{

	auto a = [](){std::cout << "Lambda is flexible!";};
	
	a();    //MinGW或VC10.0通过编译，显示结果：Lambda is flexible!   
	
	return 0;

}
```

函数中的函数

# 含有多个cpp

一个.cpp对应一个.obj,然后将所有的obj链接起来(通过一个叫链接器的程序),组成一个.exe,也就是程序了.

 如果一个.cpp要用到另一个.cpp定义的函数（默认extern）怎么办? 只需在这个.cpp#include头文件然后直接调用就可以了.其余工作由链接器帮你完成,你可以随便调用该函数.

链接器将所有的obj连接起来,但是如果碰巧有相同的函数或外部变量怎么办?他如何识别?

**链接属性的关键字**

- 外部链接extern
  除了这个单元,外部的单元也是能够访问这个函数，整个程序公用

- 内部链接static
  只属于自己单元，只在一个编译单元obj中使用

  